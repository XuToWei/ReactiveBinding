using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace ReactiveBinding.Generator;

[Generator(LanguageNames.CSharp)]
public class VersionFieldGenerator : ISourceGenerator
{
    private const string IVersionInterfaceName = "ReactiveBinding.IVersion";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new VersionFieldSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not VersionFieldSyntaxReceiver receiver)
            return;

        foreach (var classData in receiver.ClassDataList)
        {
            ProcessClass(context, classData);
        }
    }

    private void ProcessClass(GeneratorExecutionContext context, VersionFieldClassData classData)
    {
        var classSymbol = classData.ClassSymbol;

        // Validate class
        if (!ValidateClass(context, classData))
            return;

        // Validate fields and filter valid ones
        var validFields = classData.Fields.Where(f => ValidateField(context, classData, f)).ToList();

        if (validFields.Count == 0)
            return;

        // Generate code
        var code = GenerateCode(classData, validFields);
        var fileName = $"VersionFieldGenerator.{classSymbol.ContainingNamespace}.{classSymbol.Name}.g.cs";
        context.AddSource(fileName, code);
    }

    private bool ValidateClass(GeneratorExecutionContext context, VersionFieldClassData classData)
    {
        var classSymbol = classData.ClassSymbol;
        var classDeclaration = classData.ClassDeclaration;
        bool isValid = true;

        // VF1001: Class must be partial
        if (!classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.VF1001_ClassNotPartial,
                classDeclaration.Identifier.GetLocation(),
                classSymbol.Name));
            isValid = false;
        }

        // VF1002: Class must implement IVersionElement
        bool implementsInterface = classSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == IVersionInterfaceName);

        if (!implementsInterface)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.VF1002_ClassNotImplementInterface,
                classDeclaration.Identifier.GetLocation(),
                classSymbol.Name));
            isValid = false;
        }

        return isValid;
    }

    private bool ValidateField(GeneratorExecutionContext context,
        VersionFieldClassData classData, VersionFieldData field)
    {
        bool isValid = true;

        // VF2001: Field must have m_ prefix
        if (!field.FieldName.StartsWith("m_") || field.FieldName.Length <= 2)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.VF2001_FieldNotPrefixed,
                field.Location,
                field.FieldName));
            isValid = false;
        }

        // VF2002: Field must be private
        if (!field.IsPrivate)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.VF2002_FieldNotPrivate,
                field.Location,
                field.FieldName));
            isValid = false;
        }

        // VF2003: Check for property name collision
        var existingProperty = classData.ClassSymbol.GetMembers(field.PropertyName)
            .OfType<IPropertySymbol>()
            .FirstOrDefault();

        if (existingProperty != null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                DiagnosticDescriptors.VF2003_PropertyAlreadyExists,
                field.Location,
                field.PropertyName,
                field.FieldName));
            isValid = false;
        }

        return isValid;
    }

    private string GenerateCode(VersionFieldClassData classData, System.Collections.Generic.List<VersionFieldData> fields)
    {
        var sb = new StringBuilder();
        var classSymbol = classData.ClassSymbol;
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        // Check if IVersion members are already implemented
        bool hasVersionProperty = classSymbol.GetMembers("Version").OfType<IPropertySymbol>().Any();
        bool hasParentProperty = classSymbol.GetMembers("Parent").OfType<IPropertySymbol>().Any();
        bool hasIncrementVersionMethod = classSymbol.GetMembers("IncrementVersion").OfType<IMethodSymbol>().Any();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial class {className}");
        sb.AppendLine("    {");

        // Generate IVersion implementation if not already present
        if (!hasVersionProperty || !hasIncrementVersionMethod)
        {
            sb.AppendLine("        private int __version;");
            sb.AppendLine();
        }

        if (!hasParentProperty)
        {
            sb.AppendLine("        public ReactiveBinding.IVersion Parent { get; set; }");
            sb.AppendLine();
        }

        if (!hasVersionProperty)
        {
            sb.AppendLine("        public int Version => __version;");
            sb.AppendLine();
        }

        if (!hasIncrementVersionMethod)
        {
            sb.AppendLine("        public void IncrementVersion()");
            sb.AppendLine("        {");
            sb.AppendLine("            __version = ReactiveBinding.VersionCounter.Next();");
            sb.AppendLine("            if (Parent != null) Parent.IncrementVersion();");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate properties for fields
        foreach (var field in fields)
        {
            GenerateProperty(sb, field);
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private void GenerateProperty(StringBuilder sb, VersionFieldData field)
    {
        var typeName = field.TypeSymbol.ToDisplayString();
        var propertyName = field.PropertyName;
        var fieldName = field.FieldName;

        sb.AppendLine();
        sb.AppendLine($"        public {typeName} {propertyName}");
        sb.AppendLine("        {");
        sb.AppendLine($"            get => {fieldName};");
        sb.AppendLine("            set");
        sb.AppendLine("            {");

        // Generate appropriate comparison based on type
        sb.AppendLine($"                if ({GenerateInequalityCheck("value", fieldName, field.TypeSymbol)})");
        sb.AppendLine("                {");

        // For IVersion types, manage Parent chain
        if (field.IsVersionType)
        {
            sb.AppendLine($"                    if ({fieldName} != null) {fieldName}.Parent = null;");
            sb.AppendLine($"                    {fieldName} = value;");
            sb.AppendLine($"                    if (value != null) value.Parent = this;");
        }
        else
        {
            sb.AppendLine($"                    {fieldName} = value;");
        }

        sb.AppendLine("                    IncrementVersion();");
        sb.AppendLine("                }");

        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private string GenerateInequalityCheck(string left, string right, ITypeSymbol typeSymbol)
    {
        // Float: use epsilon comparison
        if (typeSymbol.SpecialType == SpecialType.System_Single)
        {
            return $"System.Math.Abs({left} - {right}) > 1e-6f";
        }
        // Double: use epsilon comparison
        if (typeSymbol.SpecialType == SpecialType.System_Double)
        {
            return $"System.Math.Abs({left} - {right}) > 1e-9d";
        }
        // All types (value and reference): use !=
        return $"{left} != {right}";
    }
}
